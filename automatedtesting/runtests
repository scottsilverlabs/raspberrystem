#!/usr/bin/env python3

#
# Copyright (c) 2014, Scott Silver Labs, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from os import path, listdir
from sys import exit
from threading import Thread, Event

targetdir = path.abspath("./rsinstall/") #Path to the top level directory
targetfile = "test.auto" #What to look for in the folders
results = []

def test(dpath, contents, stop): #fpath in this case being the path to the testing file
	global results
	print("Testing "+dpath)
	pos = 0
	fail = False
	try:
		for i in range(len(contents)):
			if stop.isSet():
				return
			pos = i+1
			line = contents[i]
			split = line.split(" -> ") #Do we want to check for a return value?
			expected = None
			ret = None
			if len(split) > 1:
				expected = eval(split[1])
				ret = eval(split[0])
			else:
				exec(contents[i])
			if ret != expected:
				print("\tAt line " + str(pos) + " expected " + str(expected) + " got " + str(ret))
				fail = True
				break
			elif ret != None:
				print("\t" + str(ret) + " = " + str(expected))
	except Exception as e:
		print("\t" + dpath + "/" + targetfile + " errored at line " + str(pos) + ": " + str(e))
		results.append([dpath, "Errored"])
		return
	if not fail:
		print(dpath+":Passed")
		results.append([dpath, "Passed"])
	else:
		print(dpath+":Failed")
		results.append([dpath, "Failed"])

def checkDir(dpath):
	if path.isdir(dpath) and path.exists(dpath+"/"+targetfile):
		stop = Event()
		f = open(dpath + "/" + targetfile, "r")
		contents = f.readlines()
		f.close()
		timeout = 20
		if contents[0][0:10] == "TIMEOUT = ":
			timeout = eval(contents[0][10:])
			#contents = contents[1:]
		thread = Thread(target = test, args = (dpath, contents, stop))
		thread.setDaemon(True)
		thread.start()
		thread.join(timeout)
		if thread.is_alive():
			stop.set() #Not reliable if it's an infinite loop issue.
			print(dpath+":Timeout")
			results.append([dpath, "Timeout"])


for topdir in listdir(targetdir):
	checkDir(targetdir + "/" + topdir)
	for diractual in listdir(targetdir+"/"+topdir):
		checkDir(targetdir + "/" + topdir + "/" + diractual)
print("Results:")
for i in results:
	print("\t" + path.dirname(i[0]) + ":" + i[1])
exit(0) #To kill any infinite loop threads